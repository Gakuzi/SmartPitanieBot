# Проект "Смарт Питание" (smartPit)

Это Telegram-бот, написанный на Google Apps Script, который помогает пользователям следить за своим питанием. Бот интегрирован с Google Sheets для хранения данных о меню, продуктах и планах готовки.

---

## Руководство по отладке "зависшего" Telegram-бота на Google Apps Script

Это руководство поможет систематически находить и устранять причину, по которой ваш Telegram-бот перестает отвечать, даже если в логах Google Apps Script нет очевидных ошибок.

### Шаг 1: Понять природу "зависания"

В 99% случаев бот не "зависает". Происходит **"тихий сбой"** — скрипт запускается, но либо сразу завершается из-за невидимой ошибки, либо идет по логической ветке, в которой нет команды отправить ответ пользователю.

### Шаг 2: Главный диагностический вопрос: есть ли логи?

Это первый и самый важный шаг, который делит проблему на две большие категории.

1.  Зайдите в **"Выполнения" (Executions)** вашего проекта в Apps Script.
2.  Отправьте команду боту.
3.  Посмотрите, появилась ли в списке новая запись о выполнении `doPost`.

*   **Если НЕТ новой записи:** Проблема находится **вне вашего кода**. Telegram не может достучаться до вашего скрипта. Переходите к **Сценарию А**.
*   **Если ДА, новая запись появилась:** Проблема **внутри вашего кода**. Скрипт запускается, но работает неправильно. Переходите к **Сценарию Б**.

---

### Сценарий А: Записей о выполнении `doPost` нет

**Причина:** Неправильная связь между Telegram и Google.

**Как решить:**

1.  **Развертывание (Deployment):** Любое изменение в коде требует нового развертывания.
    *   Нажмите **"Развертывание" -> "Новое развертывание"**.
    *   Убедитесь, что тип **"Веб-приложение"** и доступ **"Все"**.
    *   Нажмите **"Развернуть"**.

2.  **Обновление Вебхука (Webhook):** После каждого развертывания вы получаете **новый URL**. Telegram должен знать этот новый адрес.
    *   Скопируйте новый URL.
    *   Создайте и откройте в браузере ссылку:
      `https://api.telegram.org/bot<ВАШ_ТОКЕН>/setWebhook?url=<НОВЫЙ_URL_СКРИПТА>`
    *   Убедитесь, что браузер показал ответ: `{"ok":true,...}`.

---

### Сценарий В: Ошибка прав доступа (Permission Denied)

**Симптом:** В логах появляется ошибка `You do not have permission to call...` для сервисов Google (DriveApp, SpreadsheetApp и т.д.), даже если вы уверены, что добавили необходимые `oauthScopes` в `appsscript.json`.

**Причина:** Система разрешений Google "закэшировала" старый набор прав для вашего проекта и не запрашивает новые, несмотря на обновленный манифест.

**Как решить (принудительный сброс разрешений):**

1.  **Откройте страницу разрешений вашего аккаунта Google:**
    *   Перейдите по ссылке: [https://myaccount.google.com/permissions](https://myaccount.google.com/permissions)

2.  **Найдите ваш проект в списке:**
    *   Пролистайте список и найдите приложение с названием вашего проекта (например, "SmartPit").

3.  **Отмените доступ:**
    *   Нажмите на название проекта.
    *   Нажмите синюю кнопку **"УДАЛИТЬ ДОСТУП"** и подтвердите действие.

4.  **Повторно авторизуйте проект:**
    *   Вернитесь в редактор Google Apps Script.
    *   Запустите любую функцию, требующую разрешений (например, `setupProjectInfrastructure`).
    *   Google покажет **новое окно запроса разрешений**, в котором будут перечислены все права из вашего `appsscript.json`.
    *   **Предоставьте разрешения**.

После этой процедуры скрипт получит все необходимые права, и ошибка исчезнет.

---

### Сценарий Б: Запись о выполнении `doPost` есть, но бот молчит

**Причина:** В вашем коде происходит "тихий сбой", который не отлавливается стандартными логами.

**Как решить (Метод "Эхо-теста"):**

Этот метод позволяет на 100% изолировать проблему: она либо в базовой связи с Telegram, либо в логике основного кода.

1.  **Загрузите на сервер последнюю версию кода**, выполнив `clasp push`.

2.  **Включите режим отладки:**
    *   Откройте редактор Google Apps Script.
    *   Перейдите в **Настройки проекта -> Свойства скрипта**.
    *   Нажмите **"Добавить свойство скрипта"**.
    *   В поле "Свойство" введите `DEBUG_MODE`.
    *   В поле "Значение" введите `true`.
    *   Сохраните свойства.

3.  **Проведите тест:**
    *   Отправьте любое сообщение боту.
    *   **Ожидаемый результат:** Бот должен немедленно ответить вам тем же сообщением с припиской "".

4.  **Анализируйте результат:**
    *   **Если эхо РАБОТАЕТ:** Поздравляю, базовая связь с Telegram и ваш токен в полном порядке. Проблема находится **внутри логики основного кода** (файлы `1_main.js`, `8_gemini_api.js` и т.д.).
    *   **Если эхо НЕ РАБОТАЕТ:** Проблема находится **в базовой конфигурации**. Проверьте еще раз:
        *   Правильность **Telegram-токена** в `ScriptProperties`.
        *   Правильность **URL вебхука** (Сценарий А).
        *   Наличие необходимых **разрешений** (Сценарий В).

**Чтобы вернуться в обычный режим:**

*   Просто удалите свойство `DEBUG_MODE` или измените его значение на `false`.

## Текущая задача: Персонализированная адаптация пользователя через AI

**Цель:** ИИ должен инициировать и пошагово проводить пользователя через процесс настройки профиля, собирая данные (имя, вес, рост, возраст, пол, уровень активности) с подтверждением или возможностью изменения.

**Текущее состояние и изменения:**

*   **`doPost.js`**: Изменено для передачи полного объекта `messageData` в `handleCommand`. Это позволяет получить доступ к данным пользователя Telegram (`first_name`, `last_name`, `username`).
*   **`1_main.js` (`handleCommand`):**
    *   При получении команды `/start` извлекает `first_name`, `last_name`, `username` из `messageData.from`.
    *   Формирует персонализированный промпт для Gemini, который:
        *   Приветствует пользователя.
        *   Представляет собранные данные из Telegram (имя, фамилия, никнейм).
        *   Спрашивает, верны ли эти данные или пользователь хочет указать другие.
    *   Устанавливает состояние сессии пользователя на `awaiting_name_confirmation`.
*   **`1_main.js` (`handleUserInput`):**
    *   **Текущая проблема/задача:** Необходимо добавить или исправить логику для обработки нового состояния `awaiting_name_confirmation`.
    *   **Мысли по решению:**
        *   В `handleUserInput` будет добавлен новый `case` для `awaiting_name_confirmation`.
        *   Этот `case` будет анализировать ответ пользователя:
            *   Если пользователь подтверждает данные (например, "да", "верно", "yes"), то имя пользователя сохраняется из `session.data.telegramUser`.
            *   Если пользователь указывает другое имя, то это новое имя сохраняется.
        *   После сохранения имени, сессия переключается на `awaiting_weight`, и бот запрашивает вес, продолжая процесс сбора данных.
        *   Важно убедиться, что структура `switch` в `handleUserInput` корректна и нет дублирующихся `case` или пропущенных `break`.

---

**Важная заметка:** 38-е развертывание вернуло бота в работу и он заработал.

---